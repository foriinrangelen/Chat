// =============================================================================
// PRISMA CONFIGURATION (설정)
// =============================================================================
generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// =============================================================================
// [MODEL] User (사용자)
// - 애플리케이션의 핵심 주체입니다.
// - 실시간 접속 상태(Online/Offline)는 DB 부하 방지를 위해 Redis에서 관리하는 것을 권장합니다.
// =============================================================================
model User {
  id                 Int       @id @default(autoincrement())
  email              String    @unique
  nickname           String
  password           String
  avatar             String?   // 프로필 이미지 URL (S3/R2 등의 키 값)
  hashedRefreshToken String?   @map("hashed_refresh_token") // 보안을 위해 해싱된 토큰 저장
  
  // [메타데이터]
  createdAt          DateTime  @default(now()) @map("created_at")
  updatedAt          DateTime  @updatedAt @map("updated_at")
  deletedAt          DateTime? @map("deleted_at") // Soft Delete: 탈퇴한 시점을 기록하고 실제 데이터는 남김

  // [관계 설정: 채널]
  OwnedChannels      Channel[]       @relation("ChannelOwner")
  ChannelMembers     ChannelMember[]
  
  // [관계 설정: 워크스페이스(채팅방)]
  WorkspaceMessages  WorkspaceMessage[]
  ReadStatuses       WorkspaceReadStatus[]

  // [관계 설정: 친구]
  SentFriendships     Friendship[]   @relation("FriendshipSender")
  ReceivedFriendships Friendship[]   @relation("FriendshipReceiver")

  // [관계 설정: DM]
  DMParticipants      DMParticipant[]
  DMMessages          DMMessage[]

  @@map("users")
}

// =============================================================================
// [MODEL] Friendship (친구 관계)
// - 유저 간의 친구 요청 및 수락 상태를 관리합니다.
// =============================================================================
model Friendship {
  id         Int      @id @default(autoincrement())
  senderId   Int      @map("sender_id")   // 요청 보낸 사람
  receiverId Int      @map("receiver_id") // 요청 받은 사람
  
  // [Enum 대체] 상태값 (String)
  // - "PENDING": 요청 대기 중
  // - "ACCEPTED": 친구 수락됨
  // - "BLOCKED": 차단됨
  status     String   @default("PENDING") 
  
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  Sender   User @relation("FriendshipSender", fields: [senderId], references: [id], onDelete: Cascade)
  Receiver User @relation("FriendshipReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId]) // 중복 요청 방지
  @@index([receiverId])            // "나에게 온 친구 요청 목록" 조회 속도 향상
  @@map("friendships")
}

// =============================================================================
// [MODEL] Channel (대그룹 / 서버)
// - Slack의 'Workspace', Discord의 'Server'에 해당하는 개념입니다.
// =============================================================================
model Channel {
  id          Int       @id @default(autoincrement())
  name        String
  description String?
  icon        String?   // 채널 아이콘 이미지 URL
  
  // 초대 코드 (랜덤 UUID)
  // - 유저 초대 시 이 코드를 링크에 포함시킵니다.
  inviteCode  String    @unique @default(uuid()) @map("invite_code")
  
  ownerId     Int       @map("owner_id")
  
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  deletedAt   DateTime? @map("deleted_at") // 채널 삭제(폭파) 시점 기록

  Owner       User            @relation("ChannelOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  Members     ChannelMember[]
  Workspaces  Workspace[]     // 채널 내의 하위 채팅방들

  @@index([ownerId])
  @@map("channels")
}

// =============================================================================
// [MODEL] ChannelMember (채널 멤버십)
// - 유저가 특정 채널에 소속되어 있음을 나타내는 N:M 관계 테이블입니다.
// =============================================================================
model ChannelMember {
  channelId Int      @map("channel_id")
  userId    Int      @map("user_id")
  
  // [Enum 대체] 멤버 권한 (String)
  // - "OWNER": 소유자 (모든 권한)
  // - "ADMIN": 관리자 (채널 설정, 멤버 추방 등)
  // - "MEMBER": 일반 멤버
  role      String   @default("MEMBER")
  
  joinedAt  DateTime @default(now()) @map("joined_at") // 가입일 (신규 멤버 배지 등에 활용)

  Channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  User    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([channelId, userId]) // 복합 PK: 한 유저가 같은 채널에 두 번 가입할 수 없음
  @@index([userId])         // "내가 가입한 채널 목록" 조회용
  @@map("channel_members")
}

// =============================================================================
// [MODEL] Workspace (소그룹 / 채팅방)
// - 채널 내부의 실제 대화가 이루어지는 공간입니다.
// =============================================================================
model Workspace {
  id        Int       @id @default(autoincrement())
  name      String
  
  // [Enum 대체] 워크스페이스 타입 (String)
  // - "TEXT": 텍스트 채팅방
  // - "VOICE": 음성 대화방
  // - "VIDEO": 화상 대화방
  type      String    @default("TEXT")
  
  channelId Int       @map("channel_id")
  
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at") // 워크스페이스 삭제 시점

  Channel      Channel               @relation(fields: [channelId], references: [id], onDelete: Cascade)
  Messages     WorkspaceMessage[]
  ReadStatuses WorkspaceReadStatus[]

  @@index([channelId])
  @@map("workspaces")
}

// =============================================================================
// [MODEL] WorkspaceMessage (워크스페이스 메시지)
// - 데이터가 가장 많이 쌓이는 테이블로, 인덱싱 전략이 매우 중요합니다.
// =============================================================================
model WorkspaceMessage {
  id          Int       @id @default(autoincrement())
  content     String    @db.Text // 긴 텍스트 지원
  
  // [Enum 대체] 메시지 타입 (String)
  // - "TEXT": 일반 텍스트
  // - "IMAGE": 이미지 업로드
  // - "VIDEO": 비디오 업로드
  // - "FILE": 일반 파일
  // - "SYSTEM": 입장/퇴장 알림 등 시스템 메시지
  type        String    @default("TEXT")
  
  // 첨부파일 메타데이터 (JSON Array)
  // 예시: [{ "url": "https://...", "filename": "image.png", "size": 1024 }]
  attachments Json?       
  
  workspaceId Int       @map("workspace_id")
  userId      Int       @map("user_id") // 작성자
  
  replyToId   Int?      @map("reply_to_id") // 답장 기능 (재귀적 관계)
  isEdited    Boolean   @default(false) @map("is_edited") // 수정 여부 표시
  deletedAt   DateTime? @map("deleted_at") // 메시지 삭제 시점 (Soft Delete)
  
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  Workspace Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  User      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  ReplyTo   WorkspaceMessage?  @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  Replies   WorkspaceMessage[] @relation("MessageReplies")

  // [성능 최적화] 커서 기반 페이지네이션(Cursor Pagination)을 위한 복합 인덱스
  // 특정 워크스페이스에서 특정 시간(ID) 이전의 메시지를 빠르게 불러옵니다.
  @@index([workspaceId, createdAt]) 
  @@index([userId])
  @@map("workspace_messages")
}

// =============================================================================
// [MODEL] WorkspaceReadStatus (안 읽은 메시지 관리)
// - 유저가 각 채팅방에서 마지막으로 읽은 메시지가 무엇인지 기록합니다.
// =============================================================================
model WorkspaceReadStatus {
  userId            Int      @map("user_id")
  workspaceId       Int      @map("workspace_id")
  
  // 사용자가 마지막으로 읽은 메시지의 ID
  // (워크스페이스의 최신 메시지 ID) - (lastReadMessageId) = 안 읽은 메시지 개수(근사치)
  lastReadMessageId Int      @map("last_read_message_id")
  
  updatedAt         DateTime @updatedAt @map("updated_at")

  User      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  Workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@id([userId, workspaceId]) // PK: 유저-워크스페이스 쌍은 유일해야 함
  @@map("workspace_read_status")
}

// =============================================================================
// [MODEL] DMRoom (DM 대화방)
// - 1:1 채팅뿐만 아니라 그룹 DM 확장을 고려하여 '방(Room)' 개념을 도입했습니다.
// =============================================================================
model DMRoom {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at") // 방의 최신 상태(마지막 메시지 시간 등) 추적용

  Participants DMParticipant[]
  Messages     DMMessage[]

  @@map("dm_rooms")
}

// =============================================================================
// [MODEL] DMParticipant (DM 참여자)
// - DM 방에 누가 참여하고 있는지 관리합니다.
// =============================================================================
model DMParticipant {
  dmRoomId          Int       @map("dm_room_id")
  userId            Int       @map("user_id")
  joinedAt          DateTime  @default(now()) @map("joined_at")
  
  // 해당 DM방에서 마지막으로 읽은 메시지 ID (안 읽은 메시지 배지용)
  lastReadMessageId Int?      @map("last_read_message_id")

  DMRoom DMRoom @relation(fields: [dmRoomId], references: [id], onDelete: Cascade)
  User   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([dmRoomId, userId])
  @@index([userId]) // "내 DM 목록" 조회용
  @@map("dm_participants")
}

// =============================================================================
// [MODEL] DMMessage (DM 메시지)
// - DM 방에서 오고 가는 메시지입니다.
// =============================================================================
model DMMessage {
  id          Int       @id @default(autoincrement())
  content     String    @db.Text
  
  // [Enum 대체] 메시지 타입 (String)
  // - "TEXT", "IMAGE", "VIDEO", "FILE" 등
  type        String    @default("TEXT")
  
  attachments Json?

  dmRoomId    Int       @map("dm_room_id")
  userId      Int       @map("user_id")
  replyToId   Int?      @map("reply_to_id")
  deletedAt   DateTime? @map("deleted_at") 
  
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  DMRoom  DMRoom     @relation(fields: [dmRoomId], references: [id], onDelete: Cascade)
  User    User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  ReplyTo DMMessage? @relation("DMMessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  Replies DMMessage[] @relation("DMMessageReplies")

  @@index([dmRoomId, createdAt])
  @@map("dm_messages")
}

// =============================================================================
// [REDIS STRATEGY] Redis 활용 및 관리 가이드
// =============================================================================
/*
  DB 부하를 줄이고 고성능 실시간 채팅을 구현하기 위해, 
  아래 데이터는 PostgreSQL이 아닌 Redis(In-Memory DB)에서 관리하는 것을 권장합니다.

  1. 실시간 접속 상태 (Presence)
     - 목적: 유저가 현재 '온라인', '자리비움', '오프라인'인지 실시간 표시
     - 방식: Key-Value 사용
     - Key 패턴: `user:status:{userId}` -> Value: "online"
     - 전략: 소켓 연결 시 set, 연결 해제 시 del (Heartbeat/Ping-Pong 활용)

  2. 타이핑 인디케이터 (Typing...)
     - 목적: "OO님이 입력 중입니다..." 표시
     - 방식: String (Set with TTL)
     - Key 패턴: `typing:{channelId}:{userId}`
     - 전략: 유저가 타이핑 시작 시 Key 생성 (TTL 3초). 3초 내 재입력 없으면 자동 만료.

  3. 실시간 메시지 Pub/Sub (Socket.io Adapter)
     - 목적: API 서버가 여러 대(Scale-out)일 때 서버 간 메시지 브로드캐스팅
     - 기능: Redis Pub/Sub을 활용하여 A 서버의 유저 메시지를 B 서버의 유저에게 전달

  4. 데이터 캐싱 (Caching) - Read Heavy Data
     - 목적: 자주 조회되지만 변경이 드문 데이터의 DB 쿼리 최소화
     - 대상: 
       - 유저 프로필 정보 (`user:profile:{userId}`)
       - 채널 기본 정보 (`channel:info:{channelId}`)
     - 전략: Look-Aside 패턴 (Redis 조회 -> 없으면 DB 조회 후 적재)

  5. 인증 토큰 블랙리스트 (로그아웃 처리)
     - 목적: 로그아웃된 JWT 토큰의 재사용 방지
     - Key 패턴: `blacklist:{accessToken}`
     - 전략: 로그아웃 시 해당 토큰을 Redis에 저장하고, 토큰 만료 시간만큼 TTL 설정.
*/